## 程序进程线程
- 程序：为完成特定任务、用某种语言编写的一组指令的集合。简单来说，就是我们所写的代码。
- 进程：运行中的程序，比如我们使用QQ,就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。进程是程序的一次执行过程，或者是正在运行的一个程序。是动态过程：有他自身的产生、存在和消亡的过程。
- 线程：由进程创建，是进程的一个实体，一个进程可以拥有多个线程。
- 并发：同一时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单来说，单核cpu实现的多任务就是并发。
- 并行：同一个时刻，多个任务同时执行。多核cpu可以实现并行。并行里面也能出现并发。

## 线程的基本使用
在Java中线程使用有两种方法。
- 继承**Thread**类，重写**run**方法
- 实现**Runnable**接口，重写**run**方法

#### 继承Thread类
```java
import java.util.*;
class Cat extends Thread{
    @Override
    public void run(){
        //重写run方法，写入自己的逻辑。
        System.out.println("我都想笑了");
        //让线程休眠1秒
        try{
            Thread.sleep(1000);
        }catch (InterruptedException e){
            e.printStackTrace();
        }

    }
}

public class Test {
    public static void main(String[] args) {
        //创建一个Cat对象，可以当作线程使用
        Cat cat = new Cat();
        cat.start();
    }
}

```
当一个类继承了**Thread**类，那么这个类就可以当作一个线程类来使用。

**注意点**：Thread类的run方法实际上是去实现了**Runnable**接口中的run方法。

启动一个线程是不会阻塞主线程的，而且只是CPU在两个线程里面交替切换执行。

start方法会去启动cat的run方法，而run方法就是一个普通的方法，如果没有真正的启动一个线程，就会把run方法里面的代码执行，才向下执行。所以run方法并不是开启线程的真正方法

start方法调用start0方法后，该线程不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于CPU，由CPU统一调度。

#### 实现Runnable接口
因为java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时就继承不了**Thread**类了。
```java
class Dog implements Runnable{
    int count = 0;
    @Override
    public void run(){
        while (true){
            count++;
            System.out.println("狗再叫");
            try{
                Thread.sleep(1000);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            if(count>=10) break;
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Thread thread = new Thread(dog);
        thread.start();
    }
}
```
其中底层实现了静态代理，所以需要像这样来开启线程。
```java
        Dog dog = new Dog();
        Thread thread = new Thread(dog);
        thread.start();
```
## 线程终止
- 线程完成任务之后自动退出。
- 通过通知的方式来让某个线程停止。

如果希望主线程能去控制子线程的终止，只需要修改某个变量使其终止即可
```java
class Dog implements Runnable{
    int count = 0;
    private boolean loop = true;
    @Override
    public void run(){
        while (loop){
            count++;
            System.out.println("狗再叫");
            try{
                Thread.sleep(1000);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            if(count>=10) break;
        }
    }
    public void setLoop(boolean t){
        this.loop = t;
    }
}

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Thread thread = new Thread(dog);
        thread.start();
        //由于子线程并不会干扰主线程。在这里设置loop为false即可阻断子线程运行。
        dog.setLoop(false);
    }
}
```

## 线程常用方法