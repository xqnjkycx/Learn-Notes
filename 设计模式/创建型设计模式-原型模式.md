## 原型模式介绍
原型模式*Prototype*是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。

原型模式是一种创建型型设计模式。允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。

工作原理类似与：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己
来实施创建，即，对象.clone()

## 情景模拟
假设现在有一只绵羊，它的名字叫“花花”，年龄为1岁，毛色为白色。现在要求你通过花花这只绵羊，克隆出5只一模一样的羊

**烂代码**
```java
//创建Sheep Bean
class Sheep{
    private String name;
    private int age;
    private String color;
    public Sheep(String name, int age , String color){
        this.age = age;
        this.name = name;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
public class Test {
    public static void main(String[] args) {
        Sheep sheep0 = new Sheep("花花",1,"白色");
        //克隆羊
        Sheep sheep1 = new Sheep(sheep0.getName(),sheep0.getAge(),sheep0.getColor());
        Sheep sheep2 = new Sheep(sheep0.getName(),sheep0.getAge(),sheep0.getColor());
        Sheep sheep3 = new Sheep(sheep0.getName(),sheep0.getAge(),sheep0.getColor());
        Sheep sheep4 = new Sheep(sheep0.getName(),sheep0.getAge(),sheep0.getColor());
        Sheep sheep5 = new Sheep(sheep0.getName(),sheep0.getAge(),sheep0.getColor());
    }
}
```
这个代码所出现的问题非常大，在创建对象的时候总是重新初始化对象，而不是动态的获得对象运行时的状态，不够灵活。比如说，
之后还要对这些羊新增一个属性产毛量，你在sheep类里面新增一个属性，却要在每个new Sheep里面手动去添加一个新的get方法，
这是非常臃肿的。


为了解决这个问题，可以有另一个**思路**：java中的Object类是所有类的根类，Object提供了一个clone方法，该方法将一个java对象复制一份但是需要克隆的java类必须实现一个接口*Cloneable*，该接口表示该类
能够复制且具有复制能力 => 原型模式。

**通过原型模式克隆羊**
```java
class Sheep implements Cloneable {
    private String name;
    private int age;
    private String color;
    public Sheep(String name, int age , String color){
        this.age = age;
        this.name = name;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
    //克隆该实例，使用默认的clone方法来完成
    @Override
    protected Object clone(){
        Sheep sheep = null;
        try {
            sheep = (Sheep) super.clone();
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
        return sheep;
    };
}

public class Test {
    public static void main(String[] args) {
        Sheep sheep0 = new Sheep("花花",1,"白色");
        Sheep sheep1 = (Sheep) sheep0.clone();
        Sheep sheep2 = (Sheep) sheep0.clone();
        Sheep sheep3 = (Sheep) sheep0.clone();
        Sheep sheep4 = (Sheep) sheep0.clone();
    }
}
```

## 深拷贝
**方式一实现深拷贝**
```java
protected Object clone() throws CloneNotSupportedException{
  Object deep = null;
  //这里完成对基本数据类型和String的克隆
  deep = super.clone();
  //对引用类型的属性，进行单独处理
  /**
  * DeepProtoType是一个类，而deepCloneableTarget是这个类中的一个引用类型
  * 下面这段代码就是在演示如何克隆引用类型，这里就是用了递归
  */
  DeepProtoType deepPrototype = (DeepProtoType) deep;
  deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();
  
  //
  return deep
}
```

